# Документация по эксплуатации 
Данное приложение содержит в себе микросервис для проведения расчетов (предназначен для проведения математических расчетов и их структурировании) и микросервис для создания своих формул (макросов).  

## Содержание  
[Запуск](#Start) 

[Основыне функции calculatorServer](#calculatorServer)

[FuncList](#FuncList)  

[FuncTable](#FuncTable) 

[RangeTable](#RangeTable)

[Основыне функции functionRepositoryServer](#functionRepositoryServer)

[Создание своей функции](#CreteCF)

[Тест на сервере](#testCF)

[Инструкция по базовым операциям](#baseOperetion)

<a name="Start"><h2>Запуск</h2></a>
* functionRepositoryServer - сервер хранящий пользовательские библиотки;
* calculatorServer - сам сервер для расчетов.
  
Правильный запуск представляет собой последовательность: eurekaCalcServer -> functionRepositoryServer -> calculatorServer -> gatewayCalcServer. \
Стоит упомянуть, что библиотека с functionRepositoryServer загружаеться на calculatorServer при запуске последнего после запуска первого. Так же загрузка новых добавленных функций(макросов) в библиотеку осущетсвялеться автоматически при успешном подключении серверов друг к другу. При загруке файла библиотеки - так же.\
Если произощел сбой загрузки, то в главном меню по обращению "/main" можно загрузить библиотку с сервера вручную.
<a name="calculatorServer"><h2>Основыне функции calculatorServer</h2></a>
Предназначен для проведения математических расчетов.
<a name="FuncList"><h3>FuncList</h3></a>
Вызываеться при обращении "/list" для REST и по "/funcList" для HTML контролерров (или по ссылке в меню main).\
Представляет собой обычный калькулятор с историе вычислений. Каждую запись можно пометить через параметр "name", имена записей могут повторяться.\
__Основной запрос для расчета выражения в REST контроллере: calculateWithName/{name}/{expression}__

На записи можно ссылаться по id записи и по имени. Об этом поговорим ниже.

Через комманду "ref" можно получить результат вычисления записи (значение) по id. Так же можно "объединять" значения по нескольким id.
#### Синтаксис "ref": 
1. ref(номер_id);
2. C несколькими id:\
  2.1. ref(с_id..по_id);\
  2.2. ref(с_id..по_id, операция_объединения) операция_объединения может быть к примеру умножением (*), по умолчанию сложение (если ее не указвать как в варианте 2.1);
   
Через комманду "name" можно получить результат вычисления записи (значение) по имени. 
#### Синтаксис "name": 
1. name(имя). Если только одна переменная имеет такое имя, то вернется ее значение. Если несколько то вернеться их объединение.
2. name(имя,операция_объединения) операция_объединения может быть к примеру умножением (*), по умолчанию сложение (1);
   
Достаточно лишь указать эти комманды в выржаения и приложение подставит нужное значение перед финальным расчетом.\
Примичание: фактически можно подставить любую операцию объединения, даже из библиотек с functionRepositoryServer. Но стоит упомятуть, что комманда не проверяет операцию на "корректность", это значит, что если указать, к примеру, sqrt в кажестве операции объединения, то вы получите соверщенно сумбурный результат. Операция объединения должна принимать аргументы с левой и правой стороны.

Записи расчитываеться через специальну форму на странице funcList. И удаляються через специльную кнопку около записи или, если нужно очистить историю, то около окна расчета есть кнопка ClearAll.\ 
Сохранять результаты можно на сервере с помошью запроса (REST) "/saveList/{directory}/{fileName}", но файл будет сохранен на сервере. Для загруки запрос (REST) "loadList/{directory}/{fileName}". Просмотреть файлы на сервере можно через запрос (REST) "showFiles/{directory}"\
*__Но рекомендуеться__* скачивать расчеты с сервера(на странице funcList) с помощью специальной формы и загружать на сервер через другую. Обе они находяться около формы для расчета и очистки истории.
<a name="FuncTable"><h3>FuncTable</h3></a>
Вызываеться при обращении "/FTable" для REST и по "/funcTable" для HTML контролерров (или по ссылке в меню main).\
Представляет собой таблицу с "записями" каждая из записей может хранить разное количесво ячеек (которые хранят в себе расчеты). При этом имя записи уникальное, а имя ячеек может быть любым.\
__Основной запрос для расчета выражения в REST контроллере: calculate/{recordName}/{cellName}/{expression}__\
На записи можно ссылаться по id записи, по паре имя_запси-имя_ячеек и по паре имя_записи-порядковый_номер_ячейки. Об этом поговорим ниже.

Через комманду "ref" можно получить результат вычисления ячейки (значение) по id. Так же можно "объединять" значения по нескольким id. (все как и в FuncList)
#### Синтаксис "ref": 
1. ref(номер_id);
2. C несколькими id:\
  2.1. ref(с_id..по_id);\
  2.2. ref(с_id..по_id, операция_объединения) операция_объединения может быть к примеру умножением (*), по умолчанию сложение (если ее не указвать как в варианте 2.1);
   
Через комманду "name" можно получить результат вычисления по имени записи и ячеек. 
#### Синтаксис "name": 
1. name(имя_записи, имя_ячеек). Если только одна переменная имеет такое имя, то вернется ее значение. Если несколько то вернеться их объединение.
2. name(имя_записи, имя_ячеек, операция_объединения) операция_объединения может быть к примеру умножением (*), по умолчанию сложение (1);

Через комманду "count" можно получить результат вычисления по имени записи и порядковому номеру ячейки в данной записи. 
#### Синтаксис "count": 
1. count(имя_записи, номер_ячейки);
2. C несколькими ячейками:\
  2.1: count(имя_записи, с_номера..по_номер);\
  2.2: count(имя_записи, с_номера..по_номер, операция_объединения) операция_объединения может быть к примеру умножением (*), по умолчанию сложение (2.1);
   
Достаточно лишь указать эти комманды в выржаения и приложение подставит нужное значение перед финальным расчетом.\
Примичание: фактически можно подставить любую операцию объединения, даже из библиотек с functionRepositoryServer. Но стоит упомятуть, что комманда не проверяет операцию на "корректность", это значит, что если указать, к примеру, sqrt в кажестве операции объединения, то вы получите соверщенно сумбурный результат. Операция объединения должна принимать аргументы с левой и правой стороны.

Записи расчитываеться через специальну форму на странице funcTable. Записи удаляються через специльную кнопку около нее или, если нужно удалить все записи, то около окна расчета есть кнопка ClearAll. Ячейки можно удалять и обновлять их содержимое (кнопки для этих функций в ячейках под основными полями) в отличии от записей в FuncList.\ 
Сохранять результаты можно на сервере с помошью запроса (REST) "/saveTable/{directory}/{fileName}", но файл будет сохранен на сервере. Для загруки запрос (REST) "loadTable/{directory}/{fileName}". Просмотреть файлы на сервере можно через запрос (REST) "showFiles/{directory}"\
*__Но рекомендуеться__* скачивать расчеты с сервера(на странице funcTable) с помощью специальной формы и загружать на сервер через другую. Обе они находяться около формы для расчета и очистки истории.
<a name="RangeTable"><h3>RangeTable</h3></a>
Вызываеться при обращении "/RTable" для REST и по "/rangeTable" для HTML контролерров (или по ссылке в меню main).\
Представляет собой таблицу для расчета функции с учетом переменных меняющихся в определенном диапазоне. Т.е. она расчитывает вся значения функции при указаных диапазонах переменных. Поэтому и называеться "Диапазонная таблица". __Имя каждой таблицы должно быть уникальным__\
Основные запросы для расчета:
* calculateTable/{name}/{expression}/{ranges} - для неравномерного измения параметов (шаг задаеться вручную). синтасис для ranges(пример): x=1..5,0.5&y=0.1..2&z=5..20,1;
* distributionCalculateTable/{name}/{expression}/{ranges} - для равномерного измения параметов (шаг расчитываеться для каждого диапазона равномерно, по указонному количеству записей через обращение ":"). синтасис для ranges(пример): x=1..5&y=0.1..2&z=5..20:10; здесь мы хотим получить ровно 10 строк расчетов.

К каждой строке результата расчета таблицы можно обращаться по паре id_таблицы-порядковый_номер_результата и паре имя_таблицы-порядковый_номер_результата.

Через комманду "tref" можно получить результат вычисления (значение) по id и порядковуму номеру результата.
#### Синтаксис "tref": 
tref(id, номер_строки). Указывается номер строки из которой нужно взять значение.
   
Через комманду "tname" можно получить результат вычисления по имени таблицы и порядковуму номеру результата.
#### Синтаксис "name": 
tname(имя, номер_строки). 

Так же можно получить расчет по указанным значениям переменных через команду tcalc.
#### Синтаксис "tcalc": 
tcalc(name/id/expression, params). Указваеться либо таблицы из которой возьмется выражение, либо само выражение. И значения его параметров. __Требуеться указать все параметры__, пример: x=2&y=5
   
__Достаточно лишь указать эти комманды в выржаения в FuncTable, FuncList или самой RangeTable и приложение подставит нужное значение перед финальным расчетом__.\

Записи расчитываеться через специальну форму на странице RangeTable. Таблица удаляться через специльную кнопку под ней или, если нужно очистить все таблицы, то около окна расчета есть кнопка ClearAll. Так же можно обновлять сами таблицы после чего произойдет ее перерасчет с новыми параметрами.\ 
Сохранять результаты можно на сервере с помошью запроса (REST) "/saveTable/{directory}/{fileName}", но файл будет сохранен на сервере. Для загруки запрос (REST) "loadTable/{directory}/{fileName}". Просмотреть файлы на сервере можно через запрос (REST) "showFiles/{directory}"\
*__Но рекомендуеться__* скачивать расчеты с сервера(на странице rangeTable) с помощью специальной формы и загружать на сервер через другую. Обе они находяться около формы для расчета и очистки истории.
<a name="functionRepositoryServer"><h2>Основыне функции functionRepositoryServer</h2></a>
Этот сервер предназначен для хранения, создания и передачи библиотек на calculatorServer. 
<a name="CreteCF"><h3>Создание своей функции (макроса)</h3></a>
Макрос представляет собой последовательность вычеслений (шаги) с вводными значениями. Шаги могут выполняться определенное количество циклов, которе можно задать как целым числом, так и значением вводимого значения. 
Шаги являються переменными хранящями в себе значение и расчетное выражение. На шаги можно ссылаться в других шагах, нодящихся внутри тела функции.\
#### Для создания функции в REST:
Запрос: create/{head}/{steps}/{description}; 
* Где head содержить в себе имя обращения к функции и тип поиска аргументов. Для типа RIGHT_SIDE они будут найдены с правой стороны от имени в выражении (fib(1, 1, 3), где 1,1,3 - аргументы). 
Для TWO_SIDES - будет производиться поск всего двух аргументов с левой и правой стороны (пример: 3pow4, где 3,4 - аргументы). \
__ВАЖНО:__ Имя макроса должно быть уникальным.
Синтактис: func_name(input_var1,input_var2,input_var3):type
* steps - указываеться сами шаги и значение количества циклов. Синтактис: name_step1=step_expression1<default_value&name_step2=step_expression2<default_value:count_repeat. Через "<" указываеться значение шага по умолчанию, оно может быть равно вводимому параметру, но его указывать не обязтельно (тогда значение по умолчанию для шага будет 0).
* description - краткое описание функции.
#### Для создания функции на HTML странице:
На странице по обращению "/customFuncRepo" есть форма для создания макроса. Там указываються все те же поля что и в REST запросе (head, steps, description). Только в параметре head тип поиска аргументов определяеться автоматически, 
и указываеться как (примеры): (number)pow(degree), где number и degree вводимые параметры, тип будет TWO_SIDES; fib(one, two, count), где one, two, count - вводимые параметры, тип будет RIGHT_SIDE.
<a name="testCF"><h3>Тест на сервере</h3></a>
На сервере модно протестировать созданную функцию через запос: /testCF/{function} (пример: /testCF/(3+3)pow(9:3+2))
Или в аналочиной форме на HTML странице.

Про то как библиотека с макросами передаеться на вычислительный сервер указано в разделе Запуск.

<a name="baseOperetion"><h2>Инструкция по базовым операциям</h2></a>
* Для -,+,\*,: - аргументы указываються с левой и правой стороны. Примеры: 3*9, (4+5\*6)\*(9:3)
* Для sqrt и fact - аргументы указваються с правой стороны. Примеры: sqrt25, fact(4\*2-3)



